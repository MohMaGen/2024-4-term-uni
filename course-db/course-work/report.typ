#import "@preview/codly:1.0.0": *
#import "@preview/tablex:0.0.9": tablex, rowspanx, colspanx

#let font-size = 12pt
#let font-name = "Noto Serif Georgian"

#let author-name = "Мохов Марк Геннадьевич" 
#let author-short = "Мохов М.Г."
#let supervisor-name = "Семёнов Генадий Николаевич"
#let supervisor-short = "Семёнов Г.Н."

#let title = "Прокат автомобилей внутренний учет."


#set document(author: author-name, title: title)

#let link-color = blue

#set text(    font: font-name,
    lang: "ru",
    size: font-size,
    fallback: true,
    hyphenate: false,
    )

// Установка свойств страницы 
#set page( margin: (top:2cm, bottom:2cm, left:3cm, right:1.5cm), )

// форматирование заголовков

// Настройка блоков кода
#show: codly-init.with()

#show link: set text(fill: link-color)

// Нумерация уравнений 
#let eq_number(it) = {
    let part_number = counter(heading.where(level:1)).get()
        part_number

        it
}

#set math.equation(numbering: num =>
    ("("+(counter(heading.where(level:1)).get() + (num,)).map(str).join(".")+")"),
    supplement: [Уравнение],
    )

#show figure: align.with(center)
#set figure(supplement: [Рисунок])
#set figure.caption(separator: [ -- ])
#set figure(numbering: num =>
  ((counter(heading.where(level:1)).get() + (num,)).map(str).join(".")),)

#show figure.where(kind:table): set figure.caption(position: top)
#show figure.where(kind:table): set figure(supplement: [Таблица])
#show figure.where(kind:table): set figure(numbering: num =>
    ((counter(heading.where(level:1)).get() + (num,)).map(str).join(".")),
    )
#show figure: set block(breakable: true)

#set enum(indent: 2.5em)

#show figure.where(kind:"listing"): set figure.caption(position: top)
#show figure.where(kind:"listing"): set figure(supplement: [Листинг])
#show figure.where(kind:table): set figure(numbering: num =>
    (num,).map(str).join("."),
    )

#state("section").update("body")



// title page.
#{
	align(center, {
		block(text(size: 14pt, tracking: 2pt,
                     [Министерство  науки и высшего образования РФ\ ] + v(10pt) +
                     [Российский химико-технологический университет имени Д.И. Менделеева]))

		v(1.5cm)

                block(text(size: 14pt, [Кафедра информационных компьютерных технологий]))
	})
	align(center + horizon, {

		block(text(size: 18pt, [Отчёт по курсовой работе по дисциплине «Базы данных» на тему:]))
		block(text(size: 18pt, [«Прокат автомобилей внутренний учет.»]))

	})

	align(bottom, { 
		align(right, block(align(left, [
				Исполнитель: гр. КС-34\
				Ф.И.О. студента: Мохов М.Г.\
				Ф.И.О. руководителя: #supervisor-short \
			])))
		
		v(1.5cm)
		
		align(center, [Москва, 2024])
	})
}

#pagebreak()



#align(center, block(inset: (x: 2cm, y: 0pt), text(size: 14pt,
upper("ТЕХНИЧЕСКОЕ ЗАДАНИЕ НА КУРСОВУЮ РАБОТУ ПО ДИСЦИПЛИНЕ «Базы данных»"))))

#v(1cm)

Студенту #author-name группы КС-34

#v(1cm)

Тема курсовой работы

_«Прокат автомобилей внутренний учет.»_

#v(1cm)

Этапы разработки работы
+ #line(start: (0pt, 0.8em), length: 100%)
+ #line(start: (0pt, 0.8em), length: 100%)
+ #line(start: (0pt, 0.8em), length: 100%)
+ #line(start: (0pt, 0.8em), length: 100%)
+ #line(start: (0pt, 0.8em), length: 100%)


#v(1cm)

#tablex(
	columns: (40%, 30%, 30%),

	[Основные разделы], [Удельный вес раздела работы], [Срок выполнения],
	[Этап 1], [], [],
	[Этап 2], [], [],
	[Этап 3], [], [],
	[Этап 4], [], [],
	[Этап 5], [], [],
)

#v(1cm)

#line(start: (0pt, 0.8em), length: 100%)
#line(start: (0pt, 0.8em), length: 100%)


Дата выдачи задания #box(line(start: (0pt, 0.9em), length: 3cm))
	20#box(line(start: (0pt, 0.9em), length: 0.2cm)) г.
	#box(line(start: (0pt, 0.9em), length: 1cm))

Дата сдачи работы #box(line(start: (0pt, 0.9em), length: 3.4cm))
	20#box(line(start: (0pt, 0.9em), length: 0.2cm)) г.
	#box(line(start: (0pt, 0.9em), length: 1cm))

Дата защиты #box(line(start: (0pt, 0.9em), length: 4.35cm))
	20#box(line(start: (0pt, 0.9em), length: 0.2cm)) г.
	#box(line(start: (0pt, 0.9em), length: 1cm))

Руководитель работы #box(line(start: (0pt, 0.9em), length: 5cm))


#set page(numbering: "1")
#counter(page).update(1)

#let fli = 2.5em

#set align(left)
#set par(
        justify: true,
        linebreaks: "optimized",
        first-line-indent: fli,
        leading: 1.25em,
       )

#set text(size: font-size)

#set heading(numbering: none, outlined: true, supplement: [Раздел])
#show heading: it => {
    set align(center)
    let h-font-size = font-size
    let content = it
	let block-padding = 1.5em


    if it.level == 1 {
        counter(figure.where(kind: image)).update(0)
        //counter(figure.where(kind: table)).update(0)
        counter(math.equation).update(0)
        content = upper(content)
        h-font-size = 16pt
        block-padding = 3em

    } else if it.level == 2 {
        h-font-size = 15pt

    } else {
        h-font-size = 14pt
    }

    set block(above:block-padding, below:block-padding)
    set text( font: font-name, size: h-font-size,)
    content
}

#outline(title: "Содержание", indent: 1.5em, depth: 3,)

#set text(lang: "ru")


#pagebreak()
= Введение


#h(fli) Базы данных активно применяются  в организациях самого разного вида и назначения (от ИТ организаций, до никак не связанных с информационными технологиями организаций для хранения бюрократии различного рода). Базы данных являются основным методом организации, хранения и управлении информации, а также автоматизации бизнес-процессов. Процесс разработки базы данных включает в себя анализ предметной области, проектирования структуры данных, реализации связи между ними, а также создание инструментов для из сборки.


Целью этой курсовой работы является создание базы данных для организации по прокаты автомобилей, а также описание процесса создания этой базы данных. По большей части в этой работе будет рассмотрен процесс создания базы данных для системы обработки заказов, которая позволит хранить историю заказов со всей необходимой информацией о заказах.


В процессе выполнения работы будет выполнено проектирование инфологической и даталогической моделей базы данных, реализация схемы базы в СУБД PostgreSQL, наполнение базы осмысленными данными, а также разработка SQL-запросов, триггеров и хранимых процедур. Результаты будут представлены в виде отчета, включающего графические и текстовые материалы.

Работа демонстрирует практическое применение знаний по проектированию баз данных и написанию SQL-запросов, а также способствует развитию навыков работы с современными инструментами для управления данными.




#set heading(numbering: "1.")
#counter(heading).update(0)

#pagebreak()
= Техническое задание

#h(fli) Тема --- Прокат автомобилей внутренний учет. В задании также были представлены ключевые слова, описывающие предметную область:

*Автомобиль*: идентификационный номер, марка, компания-поставщик, число 
    штук данного типа общее, в гараже, выдано в настоящее время, выдано всего, 
    выдано в среднем за месяц, общий пробег; модель, длительность, мощность, 
    год выпуска и производитель.  

*Клиенты*: ФИО, паспортные данные, адрес, телефон; заказы, взятые 
    автомобили сейчас и в прошлом: номер, дата выдачи, дата возвращения, общая 
    стоимость заказа.  


= Инфологическая модель

#h(fli) Из технического задания я выделил четыре основных сущностей: Заказ, клиент,
	автомобиль, компания поставщик (@info-model-img). Заказ является основной
	дочерней сущностей, так как клиент может иметь различные заказы, автомобиль
	может быть заказ много раз, также поставщики могут поставлять автомобили
	для разных заказов. Заказ имеет информацию о клиенте (*ID* клиента), об
	автомобиле (*VIN Номер* автомобиля), об компании поставщике (*ID* компании
	поставщика), также заказ имеет стоимость за день, дату выдачи
	и дату возвращения. 

Клиент --- родительская сущность, хранящая всю персональную информацию об
	клиенте такую, как ФИО, паспортные данные и номер телефона. В качестве
	ключа используется поле *ID*.

Автомобиль --- родительская сущность, описывающая конкретный автомобиль. 
	Сущность автомобиля хранит в себе информацию об пробеге автомобиля,
	*VIN номер* автомобиля, а также марку. Для идентификации используется поле
	*VIΝ номер* так, как он является уникальным для каждого автомобиля.

Компания поставщик --- родительская сущность, описывающая компанию поставляющую
	автомобили. В качестве ключа используется поле *ID*.

#figure(
    kind: image,
    caption: [Инфологическая модель базы данных проката автомобилей.],
    block(inset: 1cm, image("./КБД.png"))
    )<info-model-img>


= Даталогическая модель

#h(fli) Даталогическая модель составлялась в соответствии с инфологической моделью.
	Сущность "Orders" соответствуют сущности "Заказ" из инфологической
	модели. "Orders" имеют следующие атрибуты:

	+ ``` id``` --- идентификационное поле. Числовой тип.
	+ ``` car_VIN``` --- VIN номер автомобиля. Связь один ко многим. Поле 
		является массивом символов длиной 17, в соответствии с международным
		стандартом. 

	+ ``` issue_date``` --- дата выдачи заказа. Является значением типа
		``` Date``` (в ``` postgreSQL``` этот тип отвечает за хранение
		информации об дате и времени).

	+ ``` return_date``` --- дата возвращения заказа. Так же, как и
		``` issue_date```, значение является типа ``` Date```.

	+ ``` supplier_id``` --- ID компании поставщика. Связь один ко многим.
		Является численным типом ``` INT```.

	+ ``` client_id``` --- ID клиента. Связь один ко многим.
		Является численным типом ``` INT```.

Сущность "Clients" соответствуют сущности "Клиент" из инфологической
	модели. "Clients" имеют следующий атрибуты:

	+ ``` id``` --- идентификационное поле.

	+ ``` full_name``` --- ФИО клиента. Значение является строкой.

	+ ``` id_number``` --- Номер и серия паспорта.
	+ ``` id_issue_date``` --- Дата выдачи паспорта.
	+ ``` id_insitution``` --- Код подразделения паспорта.

	+ ``` address``` --- Адрес.
	+ ``` phone``` --- Номер телефона клиента.

Сущность "Cars" соответствует сущности "Машина" из инфологической модели.
	"Cars" имеет следующие атрибуты:

	+ ``` VIN``` --- VIN номер автомобиля.
	+ ``` model``` --- Название модели и марки автомобиля.
	+ ``` milage_km``` --- Пробег автомобиля в километрах.


Сущность "Suppliers" соответствует сущности "Компания Поставщик" из 
	инфологической модели. "Suppliers" имеет следующие атрибуты:

	+ ``` id``` --- идентификационное поле.
	+ ``` name``` --- Название компании.

== Схема БД

#figure(
	kind: image,
	caption: [Даталогическая модель.],
	image("./DLD_CW.png")
)

== SQL код для создания таблиц

#raw(read("./init.sql"), block: true, lang: "sql")

== Наполнение таблиц

#raw(read("./fill.sql"), block: true, lang: "sql")

== Таблицы

#figure(
    kind: table,
    caption: [Таблица клиентов.],
    tablex(
        header-rows: 1,
        align: horizon,
        columns: (auto, 3.5cm, auto, auto, auto, auto, auto),
        ..csv("./clients.csv").flatten()
    )
)

#figure(
    kind: table,
    caption: [Таблица машин.],
    tablex(
        header-rows: 1,
        align: horizon,
        columns: (auto, auto, auto),
        ..csv("./cars.csv").flatten()
    )
)

#figure(
    kind: table,
    caption: [Таблица компаний поставщиков.],
    tablex(
        header-rows: 1,
        align: horizon,
        columns: (auto, auto),
        ..csv("./suppliers.csv").flatten()
    )
)

#figure(
    kind: table,
    caption: [Таблица заказов.],
    tablex(
        header-rows: 1,
        align: horizon,
        columns: range(7).map(it => auto),
        ..csv("./orders.csv").flatten()
    )
)

= Результаты запросов

== Список всех заказов
#raw(read("./req1.sql"), block: true, lang: "sql")

#v(1cm)
#figure(
    kind: table,
    caption: [Результат выполнения запроса 1.],
    tablex(
        columns: (0.6cm, 1.3cm, 1.9cm, 1.9cm, 4.7cm, 2.5cm, 3.5cm),
        align: horizon,
        map-cells: cell => {
            cell.content = {
                set text(size: 10pt)
                cell.content
            }
            cell
        },

        ..csv("./res1.csv").flatten()
    )
)

== Текущие компания поставщик автомобилей.

Так как информация о компании поставщике не привязана к конкретному автомобилю,
	а к заказу (автомобили могут быть перепроданы между компаниями), то
	тякущая компания поставщик автомобиля вычисляется по последнему заказу
	с этим автомобилем.

Для удобства я создал представление показывающие последние заказы каждого 
	автомобиля:

#raw(read("./last_orders_of_cars.sql"), block: true, lang: "sql")

#figure(
	kind: table,
	caption: [Последние заказы всех автомобилей.],
	tablex(
		columns: range(7).map(it => auto),
		..csv("./last_orders_of_cars.csv").flatten()
	)
)

На основе этого представления я создал функцию для определения поставщика 
	по VIN номеру автомобиля:

#raw(read("./req2.sql"), block: true, lang: "sql")

Пример использования функции для вывода поставщиков всех автомобилей:
#raw(read("./cars_suppliers.sql"), block: true, lang: "sql")

#figure(
	kind: table,
	caption: [Поставщики всех автомобилей.],
	tablex(
		columns: range(3).map(it => auto),
		..csv("./cars_suppliers.csv").flatten()
	)
)

== Выданные автомобили и автомобили в гараже в данные момент времени

#raw(read("./req3.sql"), block: true, lang: "sql")

Результат выполнения для даты ```sql '2023-1-5'```:

#figure(
	kind: table,
	caption: [Состояние автомобилей на момент ```sql '2023-1-5'```.],
	tablex(
		columns: range(3).map(it => auto),
		..csv("./res3.csv").flatten()
	)
)

== Среднее количество автомобилей выданных в месяц

В начале я создал представление отображающие количество автомобилей
    за каждый месяц (отображение считают месяцы, в которых не было заказов,
    в том числе).

#raw(read("req4.sql"), block: true, lang: "sql")

#figure(
	kind: table,
	caption: [Количество автомобилей в месяц.],
	tablex(
		columns: range(12).map(it => auto),
		..range(3).map(it => ([year], [month], [count])).flatten(),
		..csv("./res4.csv").flatten()
	)
)

Для нахождения среднего количества автомобилей по месяцам, достаточно выполнить
запрос:
```sql
SELECT AVG(o.count) AS ordered_cars_by_monthes;
```

Результат будет: $ 0.2727$

== Заказы клиента

Я создал функцию для удобного получения всех заказов клиента по
	``` ID``` клиента:

#raw(read("./req5.sql"), block: true, lang: "sql")

Пример использования, для нахождения всех заказов клиента с
	``` ID``` равным 1:

```sql
SELECT * FROM orders_of_client(1);
```

Результат выполнения:

#figure(
	kind: table,
	caption: [Заказы клиента номер 1.],
	tablex(
		columns: range(7).map(it => auto),
		..csv("./res5.csv").flatten()
	)
)

== Автомобили взяты клиентом

Я создал три функции для получения автомобилей, которые 
когда-либо бронировал клиент и за определённый период:

#raw(read("./req6.sql"), block: true, lang: "sql")

Чтобы получить автомобили клиента 3, можно выполнить простой
	запрос:

```sql
SELECT * FROM cars_of_client(3);
```

Результат выполнения:

#figure(
	kind: table,
	caption: [Автомобили клиента 5.],
	tablex(
		columns: (auto, auto),
		..csv("res6-1.csv").flatten()
	)
)

Чтобы получать взятые автомобили за определённый период можно
	выполнить следующие запросы:

```sql
SELECT * FROM cars_of_client_by_range(1, '2022-1-1', '2023-1-1');
```

#figure(
	kind: table,
	caption: [Автомобили клиента 1 с '2022-1-1' по '2023-1-1'.],
	tablex(
		columns: (auto, auto),
		..csv("res6-1.csv").flatten()
	)
)

Чтобы получить арендованный автомобиль в определённый момент
	можно выполнить запрос вида:

```sql
SELECT * FROM cars_of_client_at_moment(1, '2022-11-02');
```

#figure(
	kind: table,
	caption: [Автомобили клиента 1 с '2022-11-02'.],
	tablex(
		columns: (auto, auto),
		..csv("res6-1.csv").flatten()
	)
)

#pagebreak()

= Выводы и заключение

В ходе проекта была разработана и внедрена база данных для управления копмпнией по выдачи автомобилей на прокат. На различных этапах проекта основное внимание уделялось организации данных, их целостности и возможностям анализа.

*Основные результаты проекта:*

+ Проектирование структуры базы данных: Построены инфологическая и даталогическая модели построены инфологическая и даталогическая модели базы данных, учитывающие все ключевые сущности и их взаимосвязи.

+ Проведена нормализация данных для устранения избыточности.

+ Реализация базы данных: Были созданы таблицы и реализованы связи между ними в PostgreSQL с помощью DDL-скриптов.

+ Наполнение таблиц: Были разработаны скрипты DML для добавления данных о 
	клиентах, заказах и автомобилей, обеспечивая логическую непротиворечивость данных.

*Разработка аналитических инструментов:* Были созданы SQL-запросы для получения подробной информации об автомобилях их использования, модель позволяет проводить различные срезы состояния автомобилей, клиентов и заказов в определённые периоды времени.

Переведено с помощью DeepL.com (бесплатная версия)

#pagebreak()

= Список литературы

+   Туманов В. Е. Основы проектирования реляционных баз данных. – 2007.

+   Кириллов В. В. Основы проектирования реляционных баз данных. Учебное пособие //СПб.: ИТМО. – 1994.

+   Кузнецов С. Д. Основы современных баз данных //М: Центр Информационных Технологий. – 1998.

+   Кириллов В. В. Введение в реляционные базы данных. – БХВ-Петербург, 2012.

+   Осипов Д. Технологии проектирования баз данных. – Litres, 2022.

+   Стружкин Н. П., Годин В. В. Базы данных: проектирование. – 2017.
